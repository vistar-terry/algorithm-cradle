## 一、什么是链表

### 1.1 定义

根据数据的存储结构，数据结构可分为数组和链表。

数组：连续的内存空间。

链表：离散的内存空间。

链表通过指针将一组离散的内存块串联在一起。每个内存块称为链表的 `节点`，每个节点包含数据域和指针域。

链表相关知识点如下：

![链表](img/%E9%93%BE%E8%A1%A8.png)

### 1.2 特点

1.   动态分配存储空间，无需预先估计存储空间，使用灵活。
2.   消耗内存空间大，除存储数据外，还需存储地址。
3.   插入和删除效率高，由于使用指针连接各节点，插入和删除时只需改变指针指向即可，无需移动其他元素，时间复杂度O(1)。
4.   随机访问效率低，由于内存空间不连续，访问节点时需要从第一个节点遍历链表，时间复杂度O(n)。



### 1.3 节点分类

头节点：数据域为空，或存放链表大小，指针域存储首元节点的地址，对于一个链表，头节点不是必须的。（为了统一操作，无头空链表使用尾插法，首元结点的处理与其他不同）

首元节点：链表存储第一个数据元素的节点。

尾节点：链表存储最后一个数据元素的节点。

头指针：指向链表的第一个节点，有头节点指向头节点，没有头节点则指向首元节点。



## 二、单链表

### 2.1 定义

单链表通过任意的存储单元存储线性表中的数据元素，每个节点由`数据域`和`指针域`两部分组成，如下图，其中data为数据域，存放数据元素，next为指针域，存放其直接后继节点的地址。

![node](img/node-16610643898151.png)

### 2.2 特点

1.   单链表只能单向遍历
2.   为了统一所有节点的处理方法，可增加头节点，对于一个链表来说，头节点可有可无。

带头结点的单链表如下：

![headnodelist](img/headnodelist.png)

不带头结点的单链表如下：

![noheadnodelist](img/noheadnodelist.png)



### 2.3 基本操作原理与实现

| 序号 |  基本操作  |                             描述                             |
| :--: | :--------: | :----------------------------------------------------------: |
|  1   | initial()  |                       构造/初始化链表                        |
|  2   |  insert()  |                           插入元素                           |
|  3   |  delete()  |                           删除元素                           |
|  4   |   find()   |           按值查找，如存在返回地址，不存在返回null           |
|  5   |   size()   |               获取链表大小，即链表中元素的个数               |
|  6   | getValue() | 取值，链表不支持下标访问（当然可以实现，但也是通过指针实现的），所以用指针取出指向的节点的值 |
|  7   |  empty()   |                             判空                             |
|  8   | reverse()  |                             反转                             |

#### 2.3.1 初始化链表

就像手机电脑的配置一样，链表也有不同的配置，没有哪个更好，只有哪个适合当前的需求，基本配置项如下：

1. 是否为空
2. 头节点
3. 尾指针
4. 记录表长（大小）

链表初始化不同配置如下：

|                               | 头指针 | 头节点 | 成员节点 | 尾指针 | 记录大小 |
| :---------------------------- | :----: | :----: | :------: | :----: | :------: |
| 0. 不带头节点的空链表         |   ✔    |   ✘    |    ✘     |   ✘    |    ✘     |
| 1. 带头节点的空链表           |   ✔    |   ✔    |    ✘     |   ✘    |    ✘     |
| 2. 带头节点的非空链表(头插法) |   ✔    |   ✔    |    ✔     |   ✘    |    ✔     |
| 3. 带头节点的非空链表(尾插法) |   ✔    |   ✔    |    ✔     |   ✔    |    ✔     |



首先定义一下节点类型，数据域为`int`类型，指针域为`struct Node`类型： 

```c
typedef struct Node
{
    int data;
    struct Node* next;
} node;
```



##### 0. 不带头节点的空链表

直接头指针指向NULL。

![initial-nohead-null](img/initial-nohead-null.png)

创建一个`node`类型的指针，并令其指向`NULL`。

```c
node* initial_nohead_null()
{
    node* head = NULL; // head为头指针

    return head;
}
```



##### 1. 带头节点的空链表

只为链表分配基本的空间，包含头节点、头指针，头指针指向头节点，头节点的指针指向NULL，其中头节点数据域为空。

![initial](img/initial-head-null.png)

创建一个头节点，并使头指针指向它，令头节点的指针指向NULL。

```c
node* initial()
{
    node* head = (node*)malloc(sizeof(node)); // 创建一个头结点，head为头指针
    head->next = NULL;

    return head;
}
```



##### 2. 带头节点的非空链表(头插法)

先为链表分配基本的空间，包含头节点、头指针，头指针指向头节点，头节点的指针指向NULL，其中头节点数据域记录链表大小（当然也可以选择不记录）。

然后，使用`头插法`为链表添加初始化数据节点。

![initial-head-nonnull](img/initial-head-nonnull.png)

这里简单介绍一下`头插法`，每次在链表的头部插入节点，即每次插入新节点都是在`头节点`和`首元节点`之间插入，如下图：

![head-insert](img/head-insert.png)

如果使用头插法为一个空链表依次插入 `10, 20, 30, 40` 四个数，则链表结果会为：

![head-insert-exp](img/head-insert-exp.png)

即节点排列顺序与插入先后顺序相反，尾节点是第一个插入的节点，首元节点是最后一个插入的节点。



关于初始化函数，根据场景不同，入参也有不同的方式，比如直接输入初始化元素值、使用现有链表、初始化为多个相同的值、使用数组等等。

```c
// 直接输入初始化元素值，利用不定参数实现
node* initial_head_arglist(int num_of_data, ...)
{
    va_list arg_list;
    va_start(arg_list, num_of_data);
    node* head = (node*)malloc(sizeof(node)); // 创建一个头结点，head为头指针
    head->data = num_of_data;
    head->next = NULL;
    node* it = head; // 创建一个指针指向头结点，用于遍历链表

    // 为链表添加节点
    for (int i = 0; i < num_of_data; i++)
    {
        node* tmp = (node* )malloc(sizeof(node));
        tmp->data = va_arg(arg_list, int);
        tmp->next = NULL;
        it->next = tmp;
        it = it->next;
    }
    va_end(arg_list);
    return head;
}
```

