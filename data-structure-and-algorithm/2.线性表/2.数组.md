## 一、什么是数组

### 1.1 定义

数组（Array）是一种**线性表**数据结构。它用一组**连续的内存空间**，来存储一组具有**相同类型的数据**。

### 1.2 数组特性

1.   支持随机访问，**根据下标**随机访问的时间复杂度为 O(1)。

2.   连续的内存空间、相同类型的数据：因此可以随机访问，但为了保证**内存的连续性**，需要做大量的数据搬移工作，使增删等操作变得非常低效。

3.   线性存储，程序执行效率高。

### 1.3 时间复杂度

插入元素：O(n)，所插入位置后面的元素都要向后移动。

删除元素：O(n)，所删除位置后面的元素都要向前移动。

访问元素：O(1)，使用索引访问。

查找元素：与使用查找算法有关，如顺序查找、二分查找、插值查找等。

### 1.4 空间复杂度

数组只用来存储指定类型的数据，所以存储n个数据的空间复杂度为O(n)。



## 二、基本操作

### 2.1 插入数据

数组插入数据：（**特定场景，特殊对待**）

原数组有序：需要将插入位置k后面的数据一次后移一位。O(n)

原数组无需：将插入位置的旧元素移到最后，再在k处插入新元素。或直接将新元素放在最后。O(1)



### 2.2 删除数据

数组删除数据：（**特定场景，特殊对待**）

考虑内存连续性：

-   有序：删除k位置元素后，将后面的元素依次前移一个位置。O(n)
-   无序：用最后一个元素覆盖要删除的元素。O(1)

不考虑内存连续：

标记删除法，将要删除的元素标记（没有真正的删除），当数组空间不够时，一次性删除。但会造成内存不连续。



### 2.3 随机访问

随机访问寻址方法：a[i]_address = base_address + i * data_type_size

其中，base_address 为数组首地址，data_type_size 为每个元素的大小，依数据类型确定。

二维数组寻址：对于 m * n 的数组，$a [ i ][ j ]$ (i < m,j < n)的地址为：

address = base_address + ( i * n + j) * data_type_size



### 2.4 查找数据



## 三、其他关于数组的问题

### 3.1 数组越界问题

```
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
```

这一段程序数组越界了，输出结果和内存地址分配方式有关。

函数体内的局部变量存在栈上，且是连续压栈。在Linux进程的内存布局中，栈区在高地址空间，从高向低增长。变量i和arr在相邻地址，在内存分配时，

如果按照内存地址递减的方式进行分配，则i比arr的地址大，那么arr越界正好访问到i。当然，前提是i和arr元素同类型，否则那段代码仍是未决行为。这时无限循环输出hello world。

如果按照内存地址递增的方式进行分配，则i比arr的地址小，那么arr越界正好访问不到i，这时只输出4次hello world。



### 3.2 数组下标为什么从0开始？

从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。第一个元素的偏移为0。第i个元素的偏移就为i。但如果从1开始，第i个元素的偏移就为i-1，多了一次减法运算，这将降低CPU的运算效率。（对于底层算法开发，效率优化要做到极致。）