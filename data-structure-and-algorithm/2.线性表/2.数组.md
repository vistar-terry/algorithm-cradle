数组（Array）是一种**线性表**数据结构。它用一组**连续的内存空间**，来存储一组具有**相同类型的数据**。

数组特性：支持随机访问，**根据下标**随机访问的时间复杂度为 O(1)，如果不是根据下标查找，时间复杂度和查找算法有关，如顺序查找、二分查找、插值查找等。

线性表：每个线性表上的数据最多只有前和后两个方向。

连续的内存空间、相同类型的数据：导致可以随机访问，但也使增删等操作变得非常低效。为了保证**内存的连续性**，就需要做大量的数据搬移工作。



随机访问寻址方法：a[i]_address = base_address + i * data_type_size

base_address 为数组首地址，data_type_size 为每个元素的大小，依数据类型确定。

二维数组寻址：对于 m * n 的数组，$a [ i ][ j ]$ (i < m,j < n)的地址为：

address = base_address + ( i * n + j) * data_type_size



数组插入数据：（**特定场景，特殊对待**）

原数组有序：需要将插入位置k后面的数据一次后移一位。O(n)

原数组无需：将插入位置的旧元素移到最后，再在k处插入新元素。或直接将新元素放在最后。O(1)



数组删除数据：（**特定场景，特殊对待**）

考虑内存连续性：

-   有序：删除k位置元素后，将后面的元素依次前移一个位置。O(n)
-   无序：用最后一个元素覆盖要删除的元素。O(1)

不考虑内存连续：

标记删除法，将要删除的元素标记（没有真正的删除），当数组空间不够时，一次性删除。但会造成内存不连续。



## 数组越界

```
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
```

这一段程序数组越界了，输出结果和内存地址分配方式有关。

函数体内的局部变量存在栈上，且是连续压栈。在Linux进程的内存布局中，栈区在高地址空间，从高向低增长。变量i和arr在相邻地址，在内存分配时，

如果按照内存地址递减的方式进行分配，则i比arr的地址大，那么arr越界正好访问到i。当然，前提是i和arr元素同类型，否则那段代码仍是未决行为。这时无限循环输出hello world。

如果按照内存地址递增的方式进行分配，则i比arr的地址小，那么arr越界正好访问不到i，这时只输出4次hello world。



## 数组下标为什么从0开始？

从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。第一个元素的偏移为0。第i个元素的偏移就为i。但如果从1开始，第i个元素的偏移就为i-1，多了一次减法运算，这将降低CPU的运算效率。（对于底层算法开发，效率优化要做到极致。）